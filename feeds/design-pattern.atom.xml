<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>技術筆記</title><link href="http://twmht.github.io/blog/" rel="alternate"></link><link href="http://twmht.github.io/blog/feeds/design-pattern.atom.xml" rel="self"></link><id>http://twmht.github.io/blog/</id><updated>2014-01-30T15:30:55+08:00</updated><entry><title>Visitor Pattern -- 在結構中穿梭還同時做事</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/visitor.html" rel="alternate"></link><updated>2014-01-30T15:30:55+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-30:posts/2014/01/design-pattern/visitor.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;資料結構裡儲存了很多個元素，假設現在要對所有元素進行一項 "處理"。那麼，這項 "處理" 的程式碼應該寫在哪裡？以常理來判斷，應該要寫在表示資料結構的類別裡面，不過如果這項 "處理" 的動作不只一個的話，該怎麼辦? 每次要做新處理的時候，就必須修改資料結構的類別。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;Visitor Pattern 把 "資料結構" 和 "處理" 兩者分開，另外寫一個表示在資料結構內穿梭來去的主體 "訪客" 的類別，然後把處理交給這個類別來進行。如此一來，如果想追加新的處理動作時，只要再建立一個新的訪客即可。而在資料結構這邊，也只要能接受來敲門的訪客就能完成動作。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;這個程式是訪客穿梭在由檔案和目錄組成的資料結構內，以列印檔案總覽。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/4ff936559e5bf100a3d1.js"&gt;&lt;/script&gt;

&lt;h4&gt;Visitor (訪客) 參與者&lt;/h4&gt;
&lt;p&gt;Visitor 是對每個資料結構中的具體元素 (ConcreteAcceptor) 宣告 "已經去找過XXXX" 的 visit(XXXX) 方法。visit(XXXX) 是處理 XXXX 的方法，實際原始碼則寫在 ConcreteVisitor 那裡。例如 Visitor 類別。&lt;/p&gt;
&lt;h4&gt;ConcreteVisitor 參與者&lt;/h4&gt;
&lt;p&gt;ConcreteVisitor 是實作 Visitor 的介面。它實作 visit(XXXX) 格式的方法，然後敘述各個 ConcreteAcceptor 的處理。 在前面的程式範例中，扮演這個角色的是 ListVisitor 類別。就像 ListVisitor 的 currentdir 欄位之值會發生變化一樣，在處理 visit(XXXX) 的過程中，ConcreteVisitor 的內部狀態也會有變化。&lt;/p&gt;
&lt;h4&gt;Acceptor 參與者&lt;/h4&gt;
&lt;p&gt;Acceptor 是表示 Visitor 訪問對象的參與者。宣告接受訪客的 accept 方法。Visitor 則被傳遞給 accept 方法的引數。例如 Acceptor 介面。&lt;/p&gt;
&lt;h4&gt;ConcreteAcceptor 參與者&lt;/h4&gt;
&lt;p&gt;ConcreteAcceptor 實作 Acceptor 的介面，例如 File 以及 Directory 類別。&lt;/p&gt;</summary></entry><entry><title>Mediator Pattern -- 只要面對一個顧問</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/mediator.html" rel="alternate"></link><updated>2014-01-30T14:29:20+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-30:posts/2014/01/design-pattern/mediator.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;一個小組裡10個同樣立場的成員共同進行作業，但卻各自為政。每個成員都對別人發出指令，讓整個作業亂成一團。而且還有干擾其他成員的作業方式、不斷發生指令相左的情形。這時候如果有一個立場超然的 "顧問" 站出來說： "請各位成員把所有狀況回報給我這個顧問，我會整體做出考量後發給各位適當的指示。但是我不會插手管各位手上工作的細節"。所有成員同意顧問的提議，於是達成共識。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;每個成員都只對顧問提出報告，也只有顧問會發出指令給各個成員。成員彼此之間也不會去探問目前狀況如何，或亂發指令給其他成員。mediator 就是一個顧問，如果有困難就告訴顧問、發生什麼會影響到整個小組的事情也要告訴顧問。對於顧問提出的要求事項要確實執行。所有小組成員都不可以擅自跟其他成員溝通意見做判斷，必須透過顧問才能進行到下一個動作。而顧問則根據小組成員所提出的報告做整體性判斷，對各個成員發出指令。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;設計一個要求輸入姓名和密碼的系統登入對話方塊的 GUI 應用軟體。這個對話方塊的使用規則如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;選擇訪客 (Guest) 登入或用戶 (Login) 登入&lt;/li&gt;
&lt;li&gt;若為用戶登入，則輸入用戶名稱和密碼&lt;/li&gt;
&lt;li&gt;選擇登入則按OK，放棄登入則按 Cancel。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有以下限制:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　若選擇訪客登入，則用戶名稱和密碼要設為不可使用，無法輸入字串。
&lt;/em&gt;　若選擇用戶登入，則用戶名稱可以使用，可輸入字串。
&lt;em&gt;　若用戶名稱的位置沒輸入任何字元時，則密碼為不可使用。
&lt;/em&gt;　只要用戶名稱的位置有輸入字元，則密碼為可以使用 (若為訪客登入，則密碼當然就是不可使用)
&lt;em&gt;　若用戶名稱和密碼這兩個位置都有輸入字元時，則 OK 鍵為可使用，但若任何一個位置是空白的時候，則 OK 無法按下。(若為訪客登入，則 OK 當然永遠可以使用)
&lt;/em&gt;　Cancel 隨時都可以按下。&lt;/p&gt;
&lt;p&gt;像這樣需要協調多個物件的時候，就是 Mediator Pattern 的使用時機。不要讓物件彼此直接溝通，另設一個 "出面幫忙的顧問"，每個物件都只跟這個顧問溝通聯絡。當然，畫面輸出控制的邏輯就只要寫在顧問裡面即可。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/9277f7bbc0685c070997.js"&gt;&lt;/script&gt;

&lt;h4&gt;Mediator (正面) 參與者&lt;/h4&gt;
&lt;p&gt;Mediator 是跟 Colleague 進行溝通，規定調整的介面。例如 Mediator 介面。&lt;/p&gt;
&lt;h4&gt;ConcreteMediator 參與者&lt;/h4&gt;
&lt;p&gt;ConcreteMediator 是實作 Mediator 的介面，進行實際的調整。例如 LoginFrame 類別。&lt;/p&gt;
&lt;h4&gt;Colleague 參與者&lt;/h4&gt;
&lt;p&gt;Colleague 是規定與 Mediator 溝通的介面。例如 Colleague 介面。&lt;/p&gt;
&lt;h4&gt;ConcreteColleague 參與者&lt;/h4&gt;
&lt;p&gt;ConcreteColleague 實作 Colleague 的介面。例如 ColleagueButton、ColleagueTextField 及 ColleagueCheckbox 等幾個類別。&lt;/p&gt;</summary></entry><entry><title>Facade Pattern -- 單一窗口</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/facade.html" rel="alternate"></link><updated>2014-01-30T13:48:52+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-30:posts/2014/01/design-pattern/facade.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;程式這個東西往往愈做愈大，許多類別彼此間的影響讓關係更加錯綜複雜。因此在使用類別時，要確實了解類別之間的關係，正確依序呼叫方法。
利用大型程式進行資料處理時，必須精確控制相關的類別。既然如此，就乾脆設個處理專用的"窗口"，如此一來就不需要個別控制類別，只要把要求丟給"窗口"即可。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;Facade Pattern 能整合錯綜複雜的來龍去脈，提供較為高級的介面。Facade 參與者則是讓系統外埠看到較簡單的介面。而且 Facade 參與者還會兼顧系統內部各類別功能和互動關係，以最正確的順序利用類別。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;設計一個產生使用者 Web 網頁的程式。
以三個類別的簡單系統為例，這個系統中包含有利用郵件信箱取得姓名的資料庫(Database)、產生 HTML 檔的類別(HtmlWriter)以及提供較高級介面的類別(PageMaker，也就是 Facade 參與者)。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/2df294dc66cd9a1008ce.js"&gt;&lt;/script&gt;

&lt;h4&gt;Facade (正面) 參與者&lt;/h4&gt;
&lt;p&gt;構築成系統的其他參與者之"單一窗口"。Facade 對系統外部提供較高級且單一的介面。例如 PageMaker 類別。&lt;/p&gt;
&lt;h4&gt;構築成系統的其他參與者&lt;/h4&gt;
&lt;p&gt;其他林林種種的參與者則各司其職，Facade 參與者的存在並不會有任何影響。它們乖乖的聽從 Facade 的呼叫出來做事，但不會反過來呼叫 Facade。例如 Database 及 HtmlWriter 類別。&lt;/p&gt;
&lt;h4&gt;Client 參與者&lt;/h4&gt;
&lt;p&gt;利用 Facade Pattern 的參與者。例如 Main 類別。&lt;/p&gt;</summary></entry><entry><title>State Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/state.html" rel="alternate"></link><updated>2014-01-29T20:53:06+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-29:posts/2014/01/design-pattern/state.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;用類別來表示 "狀態" 。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;以類別來表示狀態之後，只要切換類別就能表現 "狀態變化"，而且在必須新增其它狀態時，也很清楚該編寫哪個部份。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;假設現在有一個會隨著時間改變警備狀態的金庫保全系統：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一個金庫&lt;/li&gt;
&lt;li&gt;金庫有跟保全中心連線&lt;/li&gt;
&lt;li&gt;金庫有警鈴和一般通話用的電話&lt;/li&gt;
&lt;li&gt;金庫有時鐘，監視目前的時間&lt;/li&gt;
&lt;li&gt;白天是9:00-16:59，晚間為17:00-23:59以及0:00-8:59&lt;/li&gt;
&lt;li&gt;只有白天才能使用金庫&lt;/li&gt;
&lt;li&gt;在白天使用金庫時，保全中心會保留使用紀錄&lt;/li&gt;
&lt;li&gt;若晚間使用金庫時，保全中心會接到發生異常現象的通知&lt;/li&gt;
&lt;li&gt;警鈴是24小時都可以使用&lt;/li&gt;
&lt;li&gt;一旦使用警鈴，保全中心會接收到警鈴通知&lt;/li&gt;
&lt;li&gt;一般通話用的電話是24小時都可以使用(但晚間只有答錄機服務)&lt;/li&gt;
&lt;li&gt;在白天使用電話時，就會呼叫保全中心&lt;/li&gt;
&lt;li&gt;若晚間使用電話時，則會呼叫保全中心的答錄機&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://gist.github.com/twmht/a04e437a923e01314421.js"&gt;&lt;/script&gt;

&lt;h4&gt;State 參與者&lt;/h4&gt;
&lt;p&gt;State 表示狀態。規定不同狀態下做不同處理的介面。這個介面等於是一個不同狀態所做處理的所有方法的集合。例如 State 介面。&lt;/p&gt;
&lt;h4&gt;ConcreteState 參與者&lt;/h4&gt;
&lt;p&gt;ConcreteState 是表示具體的不同狀態，具體實作在 State 所規定的介面。例如 DayState 以及 NightState 類別。&lt;/p&gt;
&lt;h4&gt;Context 參與者&lt;/h4&gt;
&lt;p&gt;Context 具有表示現在狀態的 ConcreteState，而且還規定 State Pattern 的利用者所需要的介面。例如 Context 介面以及 SafeFrame 類別。
Context 介面負責規定介面的部份，SafeFrame 類別則負責具有 ConcreteState 參與者的部份。&lt;/p&gt;</summary></entry><entry><title>Memento Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/memento.html" rel="alternate"></link><updated>2014-01-28T19:16:28+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-28:posts/2014/01/design-pattern/memento.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;在文書軟體的操作環境下，即使不小心誤刪除了某些文字內容，只要利用 undo 功能就能救回被刪除前的內容。有些文書軟體甚至支援一次以上的還原動作。
物件導向程式如果要執行復原，必須預先儲存物件個體的狀態。但是又不能只做儲存的動作，否則無法以儲存的情報將物件的個體復原的原始的狀態。
必須要能自由存取物件個體內部的情報，才能還原物件個體。不過如果對存取動作毫不設限，又會讓高度依賴類別內部結構的程式碼分散到程式各處，增加修改類別時的困擾。這稱為封裝式破壞。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;加入表示物件個體狀態的功能，而能在執行儲存以及復原時不發生封裝性破壞。它會讓某個時間點的物件個體狀態紀錄儲存起來，等到以後再讓物件個體復原到當時的狀態。例如:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;undo (復原)&lt;/li&gt;
&lt;li&gt;redo (重複)&lt;/li&gt;
&lt;li&gt;history (產生操作紀錄)&lt;/li&gt;
&lt;li&gt;snapshot (儲存目前狀態)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;模擬一個收集水果的骰子遊戲，遊戲規則很簡單:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遊戲會自動進行&lt;/li&gt;
&lt;li&gt;遊戲的主人翁丟骰子，根據骰子的結果&lt;/li&gt;
&lt;li&gt;出現好的點數，則金錢增加。&lt;/li&gt;
&lt;li&gt;出現不好的點數，則金錢減少。&lt;/li&gt;
&lt;li&gt;出現很好的點數，可額外得到一個水果。&lt;/li&gt;
&lt;li&gt;玩到沒錢時，遊戲結束。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;為了後面能不受影響繼續進行，程式中儲存金錢的位置有建立一個 Memento 類別的物件個體，用來儲存 "目前的狀態"。裡面儲存的是現階段有的金錢和水果。利用預先儲存起來的 Memento 物件個體可以回復到原先的狀態，避免如果一直輸到沒有錢的時候會結束程式。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/3bb699572e0c4e9333d3.js"&gt;&lt;/script&gt;

&lt;h4&gt;Originator (產生者) 參與者&lt;/h4&gt;
&lt;p&gt;Originator 參與者是在想儲存本身目前狀態時產生一個 Memento 參與者。當 Originator 參與者又接收到以前的 Memento 參與者時，變進行恢復到產生 Memento 參與者時狀態的處理。例如 Gamer 類別。&lt;/p&gt;
&lt;h4&gt;Memento (紀念品) 參與者&lt;/h4&gt;
&lt;p&gt;Memento 參與者是整合 Originator 參與者的內部資訊。Memento 參與者雖然有 Originator 參與者的內部資訊，但並不會隨便把資訊公開出去。
共有以下兩種介面:
&lt;em&gt; wide interface: Memento 參與者所提供的 "wide interface" 是一個可取得物件狀態恢復原狀時之必要資訊的所有方法的集合。wide interface 會洩漏 Memento 參與者的內部狀態，所以只有 Originator 參與者能使用它。
&lt;/em&gt; narrow interface: Memento 參與者所提供的 "narrow interface" 是給外部 Carataker 參與者看的。narrow interface 能力有限，可預防內部狀態公開給外部的危險。&lt;/p&gt;
&lt;p&gt;視情況使用這兩種不同介面可以避免物件封裝化遭破壞。
扮演的角色例如 Memento 類別。&lt;/p&gt;
&lt;h4&gt;Carataker (照料的人) 參與者&lt;/h4&gt;
&lt;p&gt;如想儲存目前 Originator 參與者的狀態時，Carataker 參與者會把這個情形告訴 Originator 參與者。Originator 參與者接收這個訊息後就產生 Memento 參與者，然後傳遞給 Carataker 參與者。Carataker 為了將來可能會需要使用，因此要預先儲存這個 Memento。例如 Main 類別就是一個Carataker。
但是 Carataker 只能使用 Memento 的 narrow interface，所以不能存取 Memento 的內部資訊。 它只會把別人產生出來的 Memento 照單全收儲存起來，當作是一塊未知區域。
Originator 和 Memento 的結合相當緊密，但 Carataker 跟 Memento 的結合較為鬆散。Memento 會對 Carataker 隱藏資訊。&lt;/p&gt;</summary></entry><entry><title>Observer Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/observer.html" rel="alternate"></link><updated>2014-01-28T12:25:10+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-28:posts/2014/01/design-pattern/observer.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;observer是觀察的人，也就是觀察者的意思。
當被Observer Pattern列入觀察名單的狀態發生變化，就會通知觀察者。在寫一些跟狀態變化有關的處理時，Observer Pattern是很好用的工具。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;重點在於設計Observer Interface以及有具體實作的Observer類別。另外，也需要設計被觀察者。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;觀察者觀察產生多個數值的物件，然後輸出該值，輸出方式因觀察者而異。在這個範例中，有用數字來輸出的觀察者以及用長條圖來輸出的觀察者。&lt;/p&gt;
&lt;p&gt;在 Observer Interface 中，呼叫 update 方法的是產生數值的 NumberGenerator ( generator 是 "產生器" "產生設備" 的意思)。update 方法是 NumberGenerator 用來告訴 Observer 說 "我的內容已經更新過了，請你也更新你的輸出內容" 的方法。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/3fd90157d2327707922e.js"&gt;&lt;/script&gt;

&lt;h4&gt;Subject (被觀察者) 參與者&lt;/h4&gt;
&lt;p&gt;表示被觀察的一方。Subject 參與者具有登錄或刪除 Observer 參與者的方法。另外也有宣告了 "取得目前狀態" 的方法。例如 NumberGenerator 類別。&lt;/p&gt;
&lt;h4&gt;ConcreteSubject 參與者&lt;/h4&gt;
&lt;p&gt;表示實際 "被觀察的一方" 的參與者。一旦狀態有變化，就會立刻通知已登錄的 Observer 參與者。例如 RandomNumberGenerator 類別。&lt;/p&gt;
&lt;h4&gt;Observer 參與者&lt;/h4&gt;
&lt;p&gt;被 Subject 參與者通知 "狀態有變化" 的參與者。通知的方法是 update。例如 Observer 介面。&lt;/p&gt;
&lt;h4&gt;ConcreteObserver 參與者&lt;/h4&gt;
&lt;p&gt;實際的 Observer。一呼叫 update 方法時，即可從該方法取得 Subject 參與者的目前狀態。 例如 DigitalObserver 類別和 GraphObserver 類別。&lt;/p&gt;</summary></entry><entry><title>Proxy Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/proxy.html" rel="alternate"></link><updated>2014-01-27T20:27:42+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-27:posts/2014/01/design-pattern/proxy.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;proxy就是代理人的意思，不需要本人親自去做的事情，就交給代理人去做。代理人是代替忙到無法自己動手的本人去處理工作。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;代理人以及本人都是物件。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;這次的範例是一個把字串輸出到畫面上的列表機。由 Main 類別產生 PrinterProxy 類別的物件個體。 該物件命名為 Alice，並將此名稱輸出到畫面上。 然後改名為Bob， 且輸出該新名稱。 在命名和取得名稱的階段都還沒有產生真正的 Printer 類別(就是本人個體)，命名和取得名稱的部份由 PrinterProxy 代理執行，最後呼叫 print 方法進入真正執行列印的階段，才由 PrinterProxy 類別產生 Printer 類別的物件個體。&lt;/p&gt;
&lt;p&gt;PrinterProxy 以及 Printer 類別要一視同仁，故須定義 Printable Interface。&lt;/p&gt;
&lt;p&gt;這個程式範例的前提要件是產生 Printer 類別的物件個體會花很多時間。 為了表現出費時的感覺，所以從建構子故意呼叫 heavyJob 方法。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/1672d63393eb403671f0.js"&gt;&lt;/script&gt;

&lt;h4&gt;Subject 參與者&lt;/h4&gt;
&lt;p&gt;規定對 Proxy 參與者和 RealSubject 參與者 一視同仁的API。因為已經有 Subject 參與者，所以 Client 參與者不需要去注意 Proxy 參與者跟 RealSubject 參與者有什麼差異。 例如 Printable Interface。&lt;/p&gt;
&lt;h4&gt;Proxy 參與者&lt;/h4&gt;
&lt;p&gt;Proxy 參與者會盡量處理 Client 參與者的要求。當自己無法單獨處理時，Proxy 參與者便會把工作交給 RealSubject 參與者。 要等到真正需要用到 RealSubject 參與者時， Proxy 參與者才會產生 RealSubject 參與者。 Proxy 參與者是實作 Subject 參與者規定的 API。 例如 PrinterProxy 類別。&lt;/p&gt;
&lt;h4&gt;RealSubject 參與者&lt;/h4&gt;
&lt;p&gt;當代理人束手無策的時候，就輪到本人 RealSubject 自己上場。這個參與者跟 Proxy 參與者同樣都要實作 Subject 參與者規定的 API。例如 Printer 類別。&lt;/p&gt;
&lt;h4&gt;Client 參與者&lt;/h4&gt;
&lt;p&gt;利用 Proxy Pattern 的參與者，例如 Main 類別。&lt;/p&gt;</summary></entry><entry><title>Flyweight Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/flyweight.html" rel="alternate"></link><updated>2014-01-27T19:39:03+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-27:posts/2014/01/design-pattern/flyweight.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;當想要節省記憶體空間的時候使用。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;儘量共用物件個體，不做無謂的new。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;輸出大型文字。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/aa42efa98d66a87a5271.js"&gt;&lt;/script&gt;

&lt;h4&gt;Flyweight 參與者&lt;/h4&gt;
&lt;p&gt;表示以一般處理會讓程式變重，因此選擇共用較佳的參與者。例如BigChar類別。&lt;/p&gt;
&lt;h4&gt;Flyweight FlyweightFactory 參與者&lt;/h4&gt;
&lt;p&gt;產生Flyweight 參與者的工廠。利用這個工廠來產生 Flyweight 參與者，即可共用物件個體。　例如BigCharFactory類別。&lt;/p&gt;
&lt;h4&gt;Client 參與者&lt;/h4&gt;
&lt;p&gt;利用 FlyweightFactory 參與者產生並使用 Flyweight 參與者。例如 BigString 類別。&lt;/p&gt;</summary></entry><entry><title>Interpreter Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/interpreter.html" rel="alternate"></link><updated>2014-01-27T15:41:45+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-27:posts/2014/01/design-pattern/interpreter.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;Design Pattern 的目的之一就是要提高類別的可再用性。 可再用性是指已經產生的類別不需要多做修改或是儘量不修改就能多次使用的意思。&lt;/p&gt;
&lt;p&gt;Interpreter Pattern 是用簡單的"迷你語言"來表現程式要解決的問題，以迷你語言寫成"迷你程式"而表現具體的問題。迷你程式本身無法獨自啟動，必須先用Java語言寫另一個負責翻譯的程式(直譯器)。當能解決的問題發生變化時，要修改迷你程式來對應處理，而不是修改直譯器(儘量避免去修改)。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;當問題發生改變時，儘可能不去修改到直譯器（以Java寫成）。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;首先來定義我們的問題，我們要用迷你語言來操控玩具車。玩具車基本動作有 go, right, left　以及 repeat。&lt;/p&gt;</summary></entry><entry><title>Command Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/command.html" rel="alternate"></link><updated>2014-01-27T15:28:36+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-27:posts/2014/01/design-pattern/command.html</id><summary type="html">&lt;h3&gt;用的時間點&lt;/h3&gt;
&lt;p&gt;當類別在執行作業時，會呼叫自己類別或其他類別的方法，呼叫方法之後的結果會反應在物件狀態上，但卻不會留下任何作業紀錄。&lt;/p&gt;
&lt;p&gt;遇到這種情形的時候，要是有一個類別能表現"請執行這項作業"的"命令"時就方便多了。因為如此一來便可以用一個"表示命令的類別物件個體"來代表要執行的作業，而不需要採用"呼叫方法"之類的動態處理。如想管理相關紀錄時，只需要管理該物件個體的集合即可。而若預先將命令的集合儲存起來，還可以再執行同一個命令;或者是把多個命令結合成一個新命令供再利用。&lt;/p&gt;
&lt;h3&gt;如何設計&lt;/h3&gt;
&lt;p&gt;這樣的Pattern叫作Command Pattern，有時也稱為"Event"，跟"Event driven"中的Event是同一個意思。一旦發生事件(例如按下滑鼠左鍵，或按下右鍵)，則先將該事件變成物件個體，按照發生順序排入queue中。接著，再依序處理所有排列等候的事件。&lt;/p&gt;
&lt;h3&gt;程式範例&lt;/h3&gt;
&lt;p&gt;設計一個簡單的繪圖軟體，移動滑鼠的時候，便會自動產生一個個紅點，按下clear即可清除。
當使用者移動滑鼠的時候，就會產生"在這裡畫一個點"的command。把這個物件個體儲存起來，需要用的時候就可以繼續畫紅點。&lt;/p&gt;
&lt;script src="https://gist.github.com/twmht/613b2636b333ca809e86.js"&gt;&lt;/script&gt;

&lt;h4&gt;Command 參與者&lt;/h4&gt;
&lt;p&gt;定義command的API。例如Command Interface。&lt;/p&gt;
&lt;h4&gt;ConcreteCommand 參與者&lt;/h4&gt;
&lt;p&gt;實際上實作Command參與者的API，例如MacroCommand以及DrawCommand等類別。&lt;/p&gt;
&lt;h4&gt;Receiver 參與者&lt;/h4&gt;
&lt;p&gt;Command 參與者執行命令時的動作對象，也可以稱為受命者。例如接受DrawCommand命令的是DrawCanvas類別。&lt;/p&gt;
&lt;h4&gt;Client 參與者&lt;/h4&gt;
&lt;p&gt;在產生ConcreteCommand參與者時，分配Receiver的參與者。例如Main類別，它是配合滑鼠移動而產生 DrawCommand 的物件個體，不過同時也傳遞 DrawCommand 的物件個體給建構子，作為Receiver 參與者。&lt;/p&gt;
&lt;h4&gt;Invoker 參與者&lt;/h4&gt;
&lt;p&gt;開始執行命令的參與者，呼叫Command所定義的API。例如Main和DrawCanvas等類別都是呼叫 Command Interface 的 execute 方法。&lt;/p&gt;</summary></entry><entry><title>Iterator Pattern</title><link href="http://twmht.github.io/blog/posts/2014/01/design-pattern/iterator.html" rel="alternate"></link><updated>2014-01-26T22:42:07+08:00</updated><author><name>twmht</name></author><id>tag:twmht.github.io/blog,2014-01-26:posts/2014/01/design-pattern/iterator.html</id><summary type="html">&lt;h3&gt;Iterator Pattern是指依序掃描並且處理多個數字或變數。本身也是反覆的意思，又可以稱為迭代器。&lt;/h3&gt;
&lt;p&gt;現在要寫一個程式，可以把書籍放到書架上，並且依序印出來。&lt;/p&gt;
&lt;p&gt;Aggregate Interface，實作此Interface的類別就變成類似&lt;font color=red&gt;陣列（多個數字或變數的集合)&lt;/font&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Aggregate&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//一個可對應聚合的iterator&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="nf"&gt;iterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要掃描整個聚合時，利用iterator方法即可建立一個實作Iterator介面的類別物件個體。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Iterator&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//有沒有下一個元素&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//下一個元素&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Book類別。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Book&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;BookShelf類別就是一個聚合(放書)的實體，實作Aggregate Interface。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BookShelf&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Aggregate&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;books&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;BookShelf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxsize&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;books&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;maxsize&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Book&lt;/span&gt; &lt;span class="nf"&gt;getBookAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;books&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;appendBook&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;books&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;getLength&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="nf"&gt;iterator&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nf"&gt;BookShelfIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;BookShelfIterator實作Iterator Interface。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BookShelfIterator&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;BookShelf&lt;/span&gt; &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;BookShelfIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BookShelf&lt;/span&gt; &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;bookShelf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getLength&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Book&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getBookAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Main類別，完成整個程式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;BookShelf&lt;/span&gt; &lt;span class="n"&gt;bookShelf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BookShelf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;appendBook&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Around the World in 80 Days&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;appendBook&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bible&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;appendBook&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Cinderella&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;appendBook&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Daddy-Long-Legs&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
        &lt;span class="c1"&gt;//我們只有用到Iterator的方法，實際上BookShelf內部怎麼實作的我們不管。&lt;/span&gt;
        &lt;span class="c1"&gt;//如果今天BookShelf把陣列改成vector，下面的程式碼還是不會變動。&lt;/span&gt;
        &lt;span class="n"&gt;Iterator&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bookShelf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;iterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Book&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Book&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;book&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要多加利用Abstract class以及Interface來設計程式。&lt;/p&gt;</summary></entry></feed>