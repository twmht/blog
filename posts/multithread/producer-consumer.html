<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="author" content="twmht" />
    <meta name="robots" content="index, follow"/>

    <meta property="og:title" content="Producer-Consumer Pattern -- 我來做，你來用"/>
    <meta property="og:url" content="http://twmht.github.io/blog/posts/multithread/producer-consumer.html"/>
    <meta property="og:site_name" content="技術筆記"/>
    <meta property="og:type" content="article"/>

    <link rel="canonical" href="http://twmht.github.io/blog/posts/multithread/producer-consumer.html" />

    <title>Producer-Consumer Pattern -- 我來做，你來用 | 技術筆記</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />

    <link rel="stylesheet" type="text/css" href="http://twmht.github.io/blog/theme/css/main.css" />
    <link href="http://twmht.github.io/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="技術筆記 Atom Feed" />

    <script type="text/javascript">var switchTo5x=true;</script>
    <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">
        stLight.options({
            publisher: "",
            doNotHash: false,
            doNotCopy: false,
            hashAddressBar: false
        });
    </script>
</head>

<body id="index">
    <div class="row-fluid">
        <div class="span10 offset1">
            <header id="banner" >
                <h1>
                    <a href="http://twmht.github.io/blog/">技術筆記 </a>
                </h1>
                <nav class="navbar">
                    <div class="navbar-inner">
                        <ul class="nav">
                            <li ><a href="http://twmht.github.io/blog/category/acm.html">ACM</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/android.html">android</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/cc.html">C/C++</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/design-pattern.html">Design Pattern</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/javascript.html">javascript</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/linux.html">linux</a></li>
                            <li class="active"><a href="http://twmht.github.io/blog/category/multithread.html">Multithread</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/others.html">Others</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/python.html">Python</a></li>
                        </ul>

<script>
  (function() {
    var cx = '011100128719699788018:4mb0t5kqbse';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div id="google-custom-search" class="nav">
    <gcse:search></gcse:search>
</div>
                    </div>
                </nav>
            </header><!-- /#banner -->
        </div>
    </div>

    <div class="row-fluid">
        <div class="span10 offset1">
            <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="http://twmht.github.io/blog/posts/multithread/producer-consumer.html" rel="bookmark"
             title="Permalink to Producer-Consumer Pattern -- 我來做，你來用">Producer-Consumer Pattern -- 我來做，你來用</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="http://twmht.github.io/blog/author/twmht.html">twmht</a>
    </address>

    in <a href="http://twmht.github.io/blog/category/multithread.html">Multithread</a>

    on 2014-07-14




    
</footer><!-- /.post-info -->

        <p>Producer-Consumer Pattern是架構在之前的Guarded Suspension Pattern上，例如Producer就是Client，負責發出request，而Consumer就是Server，負責接收request。
<font color=red>而重要的的地方在於存放Data的資料結構在Producer-Consumer Pattern會有Capacity的限制</font>，如果Capacity是無限大的話，若是Producer速度很快，但是Consumer速度很慢，則Data會不斷地產生出來，那麼記憶體就會很快耗盡。</p>
<p>以下舉一個廚師（Producer）跟客人（Consumer)的例子，廚師會不停地做蛋糕放到桌上（Table)，而客人會不停地拿蛋糕起來吃。桌子最多可以放三個蛋糕，若滿了，廚師就要等，若空了，客人就要等，Capacity大小可以調整兩邊的速度。</p>
<p>廚師，MakerThread.java</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MakerThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Random</span> <span class="n">random</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Table</span> <span class="n">table</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 蛋糕的流水號(所有廚師共通)</span>
    <span class="kd">public</span> <span class="nf">MakerThread</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Table</span> <span class="n">table</span><span class="o">,</span> <span class="kt">long</span> <span class="n">seed</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">(</span><span class="n">seed</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">1000</span><span class="o">));</span>
                <span class="n">String</span> <span class="n">cake</span> <span class="o">=</span> <span class="s">&quot;[ Cake No.&quot;</span> <span class="o">+</span> <span class="n">nextId</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; by &quot;</span> <span class="o">+</span> <span class="n">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; ]&quot;</span><span class="o">;</span>
                <span class="n">table</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cake</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="kt">int</span> <span class="nf">nextId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>客人，EaterThread.java</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EaterThread</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Random</span> <span class="n">random</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Table</span> <span class="n">table</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">EaterThread</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Table</span> <span class="n">table</span><span class="o">,</span> <span class="kt">long</span> <span class="n">seed</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">(</span><span class="n">seed</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">String</span> <span class="n">cake</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">1000</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>桌子，Table.java</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Table</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">buffer</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">tail</span><span class="o">;</span>  <span class="c1">// 下一個put的地方</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">head</span><span class="o">;</span>  <span class="c1">// 下一個take的地方</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span> <span class="c1">// buffer內的蛋糕數</span>
    <span class="kd">public</span> <span class="nf">Table</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">count</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 放置蛋糕</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">cake</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; puts &quot;</span> <span class="o">+</span> <span class="n">cake</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">wait</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">buffer</span><span class="o">[</span><span class="n">tail</span><span class="o">]</span> <span class="o">=</span> <span class="n">cake</span><span class="o">;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="o">(</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">count</span><span class="o">++;</span>
        <span class="n">notifyAll</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 取得蛋糕</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">String</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">wait</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">String</span> <span class="n">cake</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">[</span><span class="n">head</span><span class="o">];</span>
        <span class="n">head</span> <span class="o">=</span> <span class="o">(</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">count</span><span class="o">--;</span>
        <span class="n">notifyAll</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; takes &quot;</span> <span class="o">+</span> <span class="n">cake</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cake</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>Main.java</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Table</span> <span class="n">table</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Table</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>     <span class="c1">// 建立可以放置3個蛋糕的桌子</span>
        <span class="k">new</span> <span class="nf">MakerThread</span><span class="o">(</span><span class="s">&quot;MakerThread-1&quot;</span><span class="o">,</span> <span class="n">table</span><span class="o">,</span> <span class="mi">31415</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">MakerThread</span><span class="o">(</span><span class="s">&quot;MakerThread-2&quot;</span><span class="o">,</span> <span class="n">table</span><span class="o">,</span> <span class="mi">92653</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">MakerThread</span><span class="o">(</span><span class="s">&quot;MakerThread-3&quot;</span><span class="o">,</span> <span class="n">table</span><span class="o">,</span> <span class="mi">58979</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">EaterThread</span><span class="o">(</span><span class="s">&quot;EaterThread-1&quot;</span><span class="o">,</span> <span class="n">table</span><span class="o">,</span> <span class="mi">32384</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">EaterThread</span><span class="o">(</span><span class="s">&quot;EaterThread-2&quot;</span><span class="o">,</span> <span class="n">table</span><span class="o">,</span> <span class="mi">62643</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">EaterThread</span><span class="o">(</span><span class="s">&quot;EaterThread-3&quot;</span><span class="o">,</span> <span class="n">table</span><span class="o">,</span> <span class="mi">38327</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h3>所有參與者</h3>
<h4>Data 參與者</h4>
<p>Data 參與者由 Producer 參與者所建立，並由 Consumer 參與者所使用。
例如 String 類別(蛋糕)。</p>
<h4>Producer 參與者</h4>
<p>Producer 參與者會建立 Data 參與者，傳遞給 Channel 參與者。例如 MakerThread。</p>
<h4>Consumer 參與者</h4>
<p>Consumer 參與者會從 Channel 參與者取得 Data 參與者。例如 EaterThread。</p>
<h4>Channel 參與者</h4>
<p>Channel 參與者會從 Producer 參與者處接收 Data 參與者，並保管起來。並應 Consumer 參與者的要求，將 Data 參與者傳送出去。為了確保安全性，Producer 參與者與 Consumer 參與者要對存取進行共用排斥。</p>
<p>當 Producer 將 Data 傳給 Channel 時，若 Channel 的狀態無法接受 Data 時，這時 Producer 會在 Channel 的狀態變成可接受之前，保持等待狀態。</p>
<p>當 Consumer 從 Channel 取得 Data 的時候，若 Channel 沒有 Data 可以給 Consumer 時，這時候 Consumer 在 Channel 可以傳送 Data 之前，保持等待狀態。</p>
<p>當存在多個 Producer 與 Consumer 時，為了使處理不互相干涉，Channel 也要進行共用互斥。</p>
<p>像這樣，Channel 介於 Producer 以及 Consumer 之間，擔任傳送 Data 之中繼站的角色。</p>
<p>例如 Table 類別。</p>
<h3>重點整理</h3>
<h4>提高 Channel 的再利用性</h4>
<p>範例程式中，Table 類別的 put 方法與 take 方法都使用 Guarded Suspension Pattern。但 MakerThread 類別與 EaterThread 類別都不相依於 Table 類別的詳細實作。也就是說，MakerThread 不必理會其它執行緒，只要呼叫 put 方法即可 ; 而 EaterThread 也是只要會呼叫 take 方法就好了。使用 synchronized、wait、notifyAll 這些考慮到多執行緒動作的程式碼，全部隱藏在 Channel 參與者裡面。</p>
<h4>直接傳遞的差別？</h4>
<p>接下來要來比較直接呼叫方法與透過 Channel 的情況。</p>
<h5>直接呼叫方法</h5>
<p>Consumer 想要取得 Data，通常是想要利用 Data 做一些處理。如果 Producer 直接呼叫 Consumer 的話，就相當於對 Data 進行處理的是 Producer 執行緒，而不是 Consumer 執行緒。</p>
<p>直接呼叫對方的方法，就好像廚師製作蛋糕直接交給客人，等客人吃完再做下一個，這樣太浪費了。</p>
<h5>透過 Channel 傳遞</h5>
<p>Producer 將 Data 交給 Channel 之後，不用等待 Consumer，而可以馬上開始至坐下一個 Data。Producer 的動作不會受到 Consumer 的進度的左右。</p>
<h4>Channel 的負荷</h4>
<p>範例程式中，廚師最多可以擺上三個蛋糕，如果要擺第四個以上，就必須要等待到客人拿走蛋糕才行。如果客人吃的很慢，那廚師也要等很久。</p>
<p>也就是說，桌上的蛋糕數量，會直接影響到緩衝 MakerThread 與 EaterThread 間處理速度的落差。而如果提高 Channel 可容許的數量，如果客人吃的很慢，則蛋糕會愈積愈多，一段時間之後還是會達到上限。</p>
<p>像 Guarded Suspension Pattern 的範例程式，使用 java.util.LinkedList，就可以實作出沒有儲存量上限的 Channel 了。但是這樣做，還是會因為 EaterThread 平均速度較慢的情況下，最後還是會因為記憶體不足，無法配置存放蛋糕的實體。</p>
<h4>以什麼順序傳遞 Data</h4>
<p>當 Channel 有多個 Data 時，要以什麼順序傳遞給 Consumer 呢？</p>
<h5>Queue -- 最先收到的先傳</h5>
<p>先進先出。</p>
<h5>Stack -- 最後收到的先傳</h5>
<p>後進先出。</p>
<h5>Priority Queue -- 優先的東西先傳</h5>
<p>給予 Data 優先順序，優先性高的先傳。</p>
<h4>共用互斥</h4>
<p>思考執行緒的共用互斥的問題時，把觀察切入點放在<em>保護著什麼</em>上面，會比較容易找到問題的癥結。可以得到下面兩個口訣。</p>
<ol>
<li>執行緒的合作要想<em>放在中間的東西</em></li>
<li>執行緒的互斥要想<em>應該保護的東西</em></li>
</ol>
<p>合作與互斥是表裡一體的。執行緒為了協調合作，所以必須進行共用互斥，使共用的東西不會毀損。而執行緒的共用互斥，也是為了讓執行緒合作才進行的。</p>
<h3>問題</h3>
<h4>1. 請在 Table 類別加上偵錯用的輸出，使執行緒是否有在進行 wait 等待能更加一目了然。</h4>
<p><script src="https://gist.github.com/twmht/d8d42a6677ce01aca943.js"></script></p>
<h4>2.請在 Table 類別中，加上用來清除桌上所有蛋糕的 clear 方法。</h4>
<p><script src="https://gist.github.com/twmht/5540391d88534e7baaa4.js"></script></p>
<h4>3.更改 Main 類別，使程式能再開始執行約 10 秒後結束掉所有執行緒，然後程式就此結束。</h4>
<p><script src="https://gist.github.com/twmht/47ba4c032e296b49677a.js"></script></p>
<h4>4. Host 類別的 execute 方法，會依照參數 count 指定的次數，連續呼叫 doHeavyJob 方法。doHeavyJob 是很繁重的工作，而且還取消不掉。當 count 參數傳入的數字一大，執行緒光是要離開 execute 方法，就要執行很久。請改寫 execute 方法，使它可以中途取消。</h4>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Host</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">doHeavyJob</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doHeavyJob</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 下面的程式碼</span>
        <span class="c1">// 是用來取代「無法取消的繁重工作」</span>
        <span class="c1">// （停留約10秒的迴圈）</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;doHeavyJob BEGIN&quot;</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">10000</span> <span class="o">&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// busy loop</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;doHeavyJob END&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>改寫後如下。
<script src="https://gist.github.com/twmht/08996bc6ec3bd377f593.js"></script></p>
<h4>5. 以下程式改寫 Table 類別，將 notifyAll 改成 notify，使用這個類別，有可能出現蛋糕無法傳遞的情況。</h4>
<p>請思考原因並寫出程式證明想法：</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Table</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">buffer</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">tail</span><span class="o">;</span>  <span class="c1">// 下一個put的地方</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">head</span><span class="o">;</span>  <span class="c1">// 下一個take的地方</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span> <span class="c1">// buffer內的蛋糕數</span>
    <span class="kd">public</span> <span class="nf">Table</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">count</span><span class="o">];</span>
        <span class="k">this</span><span class="o">.</span><span class="na">head</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 放置蛋糕</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">cake</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; puts &quot;</span> <span class="o">+</span> <span class="n">cake</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">wait</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">buffer</span><span class="o">[</span><span class="n">tail</span><span class="o">]</span> <span class="o">=</span> <span class="n">cake</span><span class="o">;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="o">(</span><span class="n">tail</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">count</span><span class="o">++;</span>
        <span class="n">notify</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 取得蛋糕</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">String</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">wait</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">String</span> <span class="n">cake</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">[</span><span class="n">head</span><span class="o">];</span>
        <span class="n">head</span> <span class="o">=</span> <span class="o">(</span><span class="n">head</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">count</span><span class="o">--;</span>
        <span class="n">notify</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; takes &quot;</span> <span class="o">+</span> <span class="n">cake</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cake</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>notify 方法只會從在 waitset 中等待的執行緒中呼叫一個。因此無關的執行緒進入 waitset 時若碰上 notify 引發該執行緒時，notify 所要進行的通知就沒意義了。</p>
<p>LazyThread 類別雖然在 Table 的實體上進行 wait，但卻是什麼都不做。Main 類別內混進 LazyThread 的執行緒並且予以執行的話，程式執行到一半會停下來。</p>
<p>這是由於為了呼叫 LazyThread，而隨便濫用 notify 方法只故。如果我們使用 notifyAll 而不是 notify 的話，即使參雜了 LazyThread 的執行緒，程式也不會停止而繼續執行。
<script src="https://gist.github.com/twmht/ed269955633cde7b11c6.js"></script></p>
<h4>6. Something 類別宣告一個 method 方法，請問這個方法有什麼功能？</h4>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Something</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
            <span class="c1">//外部沒有辦法獲得這個實體，因此不會被 notify 或 notifyAll。</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">object</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">object</span><span class="o">.</span><span class="na">wait</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>Something.method(long) 相當於 Thread.sleep(long)。</p>

      </div><!-- /.entry-content -->

    </article>
  </section>
</div>
            </div>
        </div>
    </div>

    <footer id="site-footer">
        <div class="row-fluid">
            <div class="span10 offset1">
                <address>
                    <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                    </p>
                    <p>
                        <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                    </p>
                </address>
            </div>
        </div>
    </footer>

    <script src="//code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>
</body>
</html>