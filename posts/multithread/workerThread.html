<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="author" content="twmht" />
    <meta name="robots" content="index, follow"/>

    <meta property="og:title" content="Worker Thread Pattern -- 等到工作來，來了就工作"/>
    <meta property="og:url" content="http://twmht.github.io/blog/posts/multithread/workerThread.html"/>
    <meta property="og:site_name" content="技術筆記"/>
    <meta property="og:type" content="article"/>

    <link rel="canonical" href="http://twmht.github.io/blog/posts/multithread/workerThread.html" />

    <title>Worker Thread Pattern -- 等到工作來，來了就工作 | 技術筆記</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />

    <link rel="stylesheet" type="text/css" href="http://twmht.github.io/blog/theme/css/main.css" />
    <link href="http://twmht.github.io/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="技術筆記 Atom Feed" />

    <script type="text/javascript">var switchTo5x=true;</script>
    <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">
        stLight.options({
            publisher: "",
            doNotHash: false,
            doNotCopy: false,
            hashAddressBar: false
        });
    </script>
</head>

<body id="index">
    <div class="row-fluid">
        <div class="span10 offset1">
            <header id="banner" >
                <h1>
                    <a href="http://twmht.github.io/blog/">技術筆記 </a>
                </h1>
                <nav class="navbar">
                    <div class="navbar-inner">
                        <ul class="nav">
                            <li ><a href="http://twmht.github.io/blog/category/acm.html">ACM</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/android.html">android</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/cc.html">C/C++</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/design-pattern.html">Design Pattern</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/javascript.html">javascript</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/linux.html">linux</a></li>
                            <li class="active"><a href="http://twmht.github.io/blog/category/multithread.html">Multithread</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/others.html">Others</a></li>
                            <li ><a href="http://twmht.github.io/blog/category/python.html">Python</a></li>
                        </ul>

<script>
  (function() {
    var cx = '011100128719699788018:4mb0t5kqbse';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div id="google-custom-search" class="nav">
    <gcse:search></gcse:search>
</div>
                    </div>
                </nav>
            </header><!-- /#banner -->
        </div>
    </div>

    <div class="row-fluid">
        <div class="span10 offset1">
            <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="http://twmht.github.io/blog/posts/multithread/workerThread.html" rel="bookmark"
             title="Permalink to Worker Thread Pattern -- 等到工作來，來了就工作">Worker Thread Pattern -- 等到工作來，來了就工作</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="http://twmht.github.io/blog/author/twmht.html">twmht</a>
    </address>

    in <a href="http://twmht.github.io/blog/category/multithread.html">Multithread</a>

    on 2014-07-14

        |
        tags:         <a href="http://twmht.github.io/blog/tag/thread.html">thread</a>
        <a href="http://twmht.github.io/blog/tag/java.html">java</a>



    
</footer><!-- /.post-info -->

        <p>在 Worker Thread Pattern 中，worker thread 會依序抓一件工作來執行。當沒有工作時，worker thread 會停下來等待新的工作過來。</p>
<p>worker thread 也有人稱為 Background Thread。也有人把視點放在管理 worker thread 的地方，稱之為 thread pool。</p>
<p>程式範例：
<script src="https://gist.github.com/twmht/32e3250dc6035a60ed94.js"></script></p>
<h3>所有參與者</h3>
<h4>Client</h4>
<p>Client 會建立 Requset，傳給 Channel。例如 ClientThread 類別。</p>
<h4>Channel</h4>
<p>Channel 從 Client 取得 Request，傳給 Worker。例如 Channel 類別。</p>
<h4>Worker</h4>
<p>Worker 會從 Channel 取得 Request，並執行這份工作。當工作結束以後，會去拿取下一個 Request。例如 WorkerThread 類別。</p>
<h4>Request</h4>
<p>Request 用來表示工作，存放這份工作所需要的資料。例如 Request 類別。</p>
<h3>重點</h3>
<h4>啟動執行緒也需要花時間</h4>
<p>Worker Thread 重複使用執行緒，不像 Thread-Per-Message Pattern，它不會一直去建立新的執行緒。</p>
<h4>控制承載量</h4>
<p>提高 Worker 的數量，可以提高並行處理的工作量。但如果準備的 Worker 數量比同時間的工作還要多，有些 worker 也派不上用場。所以有必要配合實際的需要，來調整 worker 的數量。</p>
<p>worker 的數量，可以有機動性變化：</p>
<ul>
<li>最先從某個一定量的 worker 開始</li>
<li>當工作量增加時，增加 worker 數量</li>
<li>不過增加太多會用光記憶體，所以到達某個上限要停止增加</li>
<li>相反地，工作減少時(也就是待命中的 worker 增加時)，就結束掉一些 worker。</li>
</ul>
<h4>Request 的數量</h4>
<p>增加 Channel 可以存放的 Request 數量，可緩衝 Client 與 Worker 的處理速度差，但是如果儲存太多 Request，也會佔用大量記憶體資源。</p>
<h4>Invocation 與 Execution 的分離</h4>
<p>在 Worker Thread Pattern 與 Thread-Per-Message Pattern 中，將方法的啟動與執行分開，這也是 Command Pattern 的應用。有以下好處：</p>
<ul>
<li>提高回應性</li>
<li>控制優先順序(可控制 Request 的處理優先順序)</li>
<li>可取消，可重複執行(雖然呼叫了，但是沒有執行。只要產生 Request，就可以重複執行)</li>
<li>分散處理的第一步(呼叫跟執行可以在不同的電腦上執行，相當於 Request 可以透過網路傳送到另外一台電腦上)</li>
</ul>
<h4>增加工作的種類</h4>
<p>可以藉由建立 Request 的子類別，來增加工作的種類，Channel 以及 Worker 都不需要修改，即使增加工作的種類，Worker 都只是呼叫 Request 的 execute 方法而已。</p>
<h4>如果只有一個 worker</h4>
<p>那就不需要共用互斥了。</p>
<h3>問題</h3>
<h4>1. 改寫 Channle 類別，使得請求傳進來時，就產生一個新的執行緒來處理請求。</h4>
<p>改寫後的 Channel 類別。</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Channel</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Channel</span><span class="o">(</span><span class="kt">int</span> <span class="n">threads</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startWorkers</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">putRequest</span><span class="o">(</span><span class="kd">final</span> <span class="n">Request</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">request</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h4>2. 以下的 GUI 程式中，預期結果是每秒之後的 label 會遞增顯示新的數字。但是結果是十秒之後直接顯示 9。請修改程式達成預期結果。</h4>
<script src="https://gist.github.com/twmht/ce69641ee03d614f6d64.js"></script>

<p>原因就在於說 event-dispatching thread 要離開 actionPerformed 方法之後才會更新畫面。</p>
<p>採取 Thread-Per-Message 解決這個問題，在 countUp 方法中，啟動 invokerThread 執行緒。這個執行緒執行實際的累算動作。呼叫出 CountUp 的執行緒(Event Dispatching Thread) 啟動 invokerThread，馬上就從 countUp 方法回來。</p>
<p>invokerThread 當中，會從 0 開始進行累算，再以 sleep 方法休息約一秒。invokerThread 並非 event-dispatching thread。為了讓 event-dispatching thread 執行 setText 方法，就要使用 <code>SwingUtilities.invokeLater(executor)</code>，其中 executor 是一個 Runnable 物件，它執行了 setText 方法。</p>
<script src="https://gist.github.com/twmht/4ab2c19e70bc0cb5aa7d.js"></script>

<h4>3. 為了使程式在 5 秒內結束，將 Main 類別做了修改，請做出下列的其他修改。</h4>
<ul>
<li>
<p>在 Channel 類別加上 stopAllWorker 方法。這個方法可以用來結束掉所有 Channel 類別所管理的 WorkerThread 的執行緒。</p>
</li>
<li>
<p>在 ClientThread 類別加上 stopThread 方法，這個方法可以用來結束掉 ClientThread 的執行緒。</p>
</li>
</ul>
<p>修改後的 Main 類別。</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Channel</span> <span class="n">channel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Channel</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>   <span class="c1">// 工人執行緒個數</span>
        <span class="n">channel</span><span class="o">.</span><span class="na">startWorkers</span><span class="o">();</span>
        <span class="n">ClientThread</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClientThread</span><span class="o">(</span><span class="s">&quot;Alice&quot;</span><span class="o">,</span> <span class="n">channel</span><span class="o">);</span>
        <span class="n">ClientThread</span> <span class="n">bobby</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClientThread</span><span class="o">(</span><span class="s">&quot;Bobby&quot;</span><span class="o">,</span> <span class="n">channel</span><span class="o">);</span>
        <span class="n">ClientThread</span> <span class="n">chris</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClientThread</span><span class="o">(</span><span class="s">&quot;Chris&quot;</span><span class="o">,</span> <span class="n">channel</span><span class="o">);</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">bobby</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">chris</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">stopThread</span><span class="o">();</span>
        <span class="n">bobby</span><span class="o">.</span><span class="na">stopThread</span><span class="o">();</span>
        <span class="n">chris</span><span class="o">.</span><span class="na">stopThread</span><span class="o">();</span>
        <span class="n">channel</span><span class="o">.</span><span class="na">stopAllWorkers</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>我們不去用 Thread 類別的 stop 方法，這是因為 stop 方法即使是對鎖定的執行緒，也能讓它結束，所以較不安全。</p>
<p>採取 Two Phase Termination Pattern 來解決此問題。</p>
<script src="https://gist.github.com/twmht/dab196e0d01c2f986db8.js"></script>

      </div><!-- /.entry-content -->

    </article>
  </section>
</div>
            </div>
        </div>
    </div>

    <footer id="site-footer">
        <div class="row-fluid">
            <div class="span10 offset1">
                <address>
                    <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                    </p>
                    <p>
                        <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                    </p>
                </address>
            </div>
        </div>
    </footer>

    <script src="//code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>
</body>
</html>